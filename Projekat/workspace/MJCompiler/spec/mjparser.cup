package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
    /* Following methods are redefined in purpose of different error message output */
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
    	done_parsing();
      	report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
            
        log.error(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
		
	return s;
:}


/* Keyword terminals */
terminal					PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT;
terminal					READ, RETURN, VOID, EXTENDS, CONTINUE, THIS, SUPER, GOTO, RECORD;

/* Identifier terminals */
terminal	String			IDENT;

/* Constant terminals */
terminal	Integer			NUMBER;
terminal	Character 		CHAR;
terminal	Boolean			BOOL;
	
/* Operator terminals */
terminal					PLUS, MINUS, MUL, DIV, PERCENT, EQ, NEQ, GT, GTE, LT, LTE, AND ,OR, EQUAL, PLUSPLUS;
terminal					MINUSMINUS, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;

/* Nonterminals */
nonterminal					DeclList, Decl;
nonterminal					ConstListDecls, ConstDeclList, ConstDecl, ConstDeclType;
nonterminal					Label;
nonterminal					RecordDecl;
nonterminal					VarListDeclList, VarListDecls, VarDeclList, VarDecl, VarListDeclsType;
nonterminal					ClassDecl, ClassMethodDecls, MethodDeclList, MethodDecl;
nonterminal					FormPars, FormParamList, FormParam;
nonterminal					Statements, StatementList, Statement, SingleStatement, DoStatementStart;
nonterminal					Designator, DesignatorStatement, IndexingList, Indexing;
nonterminal					OptActPars, ActPars, PrintPars;
nonterminal					Mulop, Addop, Assignop, Relop;
nonterminal					Condition, CondTerm, CondFact;

nonterminal		rs.etf.pp1.symboltable.concepts.Obj		ProgName, Program;
nonterminal		rs.etf.pp1.symboltable.concepts.Obj		MethodIdent;
nonterminal		rs.etf.pp1.symboltable.concepts.Struct	Type, ReturnType;
nonterminal		rs.etf.pp1.symboltable.concepts.Struct	RecordName, ClassIdent, ExtendsClause;
nonterminal		rs.etf.pp1.symboltable.concepts.Struct	Const, Expr, Term, Factor;

/* Priorities */
precedence		left		ELSE;

/* Grammar Rules */
Program 			::=		(Program) PROG ProgName:p DeclList LBRACE MethodDeclList RBRACE;

ProgName			::=		(ProgName) IDENT:progName;

DeclList			::=		(Declarations) DeclList Decl
							|
							(NoDeclarations) /* epsilon */;
							
Decl				::=		(DeclConst) ConstListDecls
							|
							(DeclVar)	VarListDecls
							|
							(DeclClass) ClassDecl
							|
							(DeclRecord) RecordDecl
							|
							error SEMI
							|
							error COMMA;

ConstListDecls		::=		(ConstListDeclarations) CONST ConstDeclType ConstDeclList SEMI;

ConstDeclType		::=		(ConstDeclType) Type;

ConstDeclList		::=		(MultipleConstDecls) ConstDeclList COMMA ConstDecl
							|
							(SingleConstDecl) ConstDecl;
							
ConstDecl			::=		(ConstDecl) IDENT:constName EQUAL Const:c;

Const				::=		(NumConst) NUMBER:numVal
							|
							(CharConst) CHAR:charVal
							|
							(BoolConst) BOOL:boolVal;		
							
Type				::=		(Type) IDENT:typeName;

Label				::=		(Label) IDENT;

VarListDecls		::=		(VarListDeclarations) VarListDeclsType VarDeclList SEMI;

VarListDeclsType	::= 	(VarListDeclsType) Type;

VarDeclList			::=		(MultipleVarDecls) VarDeclList COMMA VarDecl
							|
							(SingleVarDecl) VarDecl;
							
VarDecl				::=		(VarDeclBrackets) IDENT:varName LBRACKET RBRACKET
							|
							(VarDeclNoBrackets) IDENT:varName;

ClassDecl			::=		(ClassDeclaration) CLASS ClassIdent:c LBRACE VarListDeclList ClassMethodDecls RBRACE;

ClassIdent			::=		(ClassIdent) IDENT:name ExtendsClause:e;

ExtendsClause		::=		(Extends) EXTENDS Type
							|
							(NoExtends) /* epsilon */;
					
VarListDeclList		::=		(VarListDeclarationList) VarListDeclList VarListDecls
							|
							(NoVarListDeclarationList) /* epsilon */;
							
RecordDecl			::=		(RecordDeclaration) RECORD RecordName:r LBRACE VarListDeclList RBRACE;

RecordName			::=		(RecordName) IDENT:name;
											
ClassMethodDecls	::=		(ClassMethodDeclarations) LBRACE MethodDeclList RBRACE
							|
							(NoClassMethodDeclarations) /* epsilon */;
							
MethodDeclList		::=		(MethodDeclarations) MethodDeclList MethodDecl
							|
							(NoMethodDeclarations) /* epsilon */;
							
MethodDecl			::=		(MethodDecl) MethodIdent:m LPAREN FormPars RPAREN VarListDeclList LBRACE StatementList RBRACE;

MethodIdent			::=		(MethodIdent) ReturnType:r IDENT:name;

ReturnType			::=		(RetType) Type:t
							|
							(RetVoid) VOID;
							
FormPars			::=		(FormParams) FormParamList
							|
							(NoFormParams) /* epsilon */;
							
FormParamList		::=		(MultipleFormParams) FormParamList COMMA FormParam
							|
							(SingleFormParam) FormParam;

FormParam			::=		(FormalParameterBrackets) Type IDENT:name LBRACKET RBRACKET
							|
							(FormalParameterNoBrackets) Type IDENT:name
							|
							error;
						
StatementList		::=		(Stmts) StatementList Statement
							|
							(NoStmt) /* epsilon */;
							
Statement			::=		(SingleStmtWithLabel) Label COLON SingleStatement
							|
							(SingleStmtNoLabel) SingleStatement
							|
							(MultipleStmts) Statements;

Statements			::=		(Statements) LBRACE StatementList RBRACE;

SingleStatement		::=		(IfStmt) IF LPAREN Condition RPAREN Statement
							|
							(IfElseStmt) IF LPAREN Condition RPAREN Statement ELSE Statement
							|
							(DoWhileStmt) DoStatementStart Statement WHILE LPAREN Condition RPAREN SEMI
							|
							(DesignatorStmt) DesignatorStatement SEMI
							|
							(BreakStmt) BREAK SEMI
							|
							(ContinueStmt) CONTINUE SEMI
							|
							(GotoStmt) GOTO Label SEMI
							|
							(ReturnNoExprStmt) RETURN SEMI
							|
							(ReturnExprStmt) RETURN Expr:e SEMI
							|
							(ReadStmt) READ LPAREN Designator RPAREN SEMI
							|
							(PrintStmt) PRINT LPAREN PrintPars RPAREN SEMI;
							
DoStatementStart	::=		(DoStatementStart) DO;

Expr				::=		(MultipleExpr) Expr:e Addop Term:t
							|
							(SingleExprWithMinus) MINUS Term:t
							|
							(SingleExpr) Term:t;
							
Term				::=		(MultipleTerm) Term:t Mulop Factor:f
							|
							(SingleTerm) Factor:f;

Factor				::=		(FactorWithConst) Const:c
							|
							(FactorWithParen) LPAREN Expr:e RPAREN
							|
							(FactorWithNew) NEW Type:t
							|
							(FactorWithNewArray) NEW Type:t LBRACKET Expr:e RBRACKET
							|
							(FactorDesignator) Designator
							|
							(FactorDesignatorFuncCall) Designator LPAREN OptActPars RPAREN;
							
Designator			::=		(Designator) IDENT IndexingList;

IndexingList		::=		(MultipleIndexing) IndexingList Indexing
							|
							(NoIndexing) /* epsilon */;
							
Indexing			::=		(IndexingField) DOT IDENT
							|
							(IndexingArray) LBRACKET Expr RBRACKET;
							
OptActPars			::=		(WithOptActPars) ActPars
							|
							(NoOptActPars) /* epsilon */; 
							
ActPars				::=		(MultipleActPars) ActPars COMMA Expr
							|
							(SingleActPars) Expr;
							
Mulop				::=		(Mul) MUL
							|
							(Div) DIV
							|
							(Percent) PERCENT;
							
Addop				::=		(Add) PLUS
							|
							(Minus) MINUS;
							
Assignop			::=		(Assignop) EQUAL;
	
Relop				::=		(EqualTo) EQ
							|
							(NotEqualTo) NEQ
							|
							(GreaterThen) GT
							|
							(GreaterOrEqualThen) GTE
							|
							(LessThen) LT
							|
							(LessOrEqualThen) LTE;
					
PrintPars			::=		(PrintParameters) Expr
							|
							(PrintParametersWithConst) Expr COMMA NUMBER;
							
DesignatorStatement	::=		(DesignatorStmtAssign) Designator Assignop Expr
							|
							Designator Assignop error
							|
							(DesignatorStmtFuncCall) Designator LPAREN OptActPars RPAREN
							|
							(DesignatorStmtInc) Designator PLUSPLUS
							|
							(DesignatorStmtDec) Designator MINUSMINUS;
							
Condition			::=		(MultipleConditions) Condition OR CondTerm
							|
							(SingleCondition) CondTerm
							|
							
							error;
							
CondTerm			::=		(MultipleCondTerms) CondTerm AND CondFact
							|
							(SingleCondTerm) CondFact;
							
CondFact			::=		(SingleCondFact) Expr
							|
							(DoubleCondFact) Expr Relop Expr;