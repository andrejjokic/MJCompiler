package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
    /* Following methods are redefined in purpose of different error message output */
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
    	done_parsing();
      	report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
            
        log.error(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
		
	return s;
:}


/* Keyword terminals */
terminal					PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT;
terminal					READ, RETURN, VOID, EXTENDS, CONTINUE, THIS, SUPER, GOTO, RECORD;

/* Identifier terminals */
terminal	String			IDENT;

/* Constant terminals */
terminal	Integer			NUMBER;
terminal	Character 		CHAR;
terminal					BOOL;
	
/* Operator terminals */
terminal					PLUS, MINUS, MUL, DIV, PERCENT, EQ, NEQ, GT, GTE, LT, LTE, AND ,OR, EQUAL, PLUSPLUS;
terminal					MINUSMINUS, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;

/* Nonterminals */
nonterminal					DeclList DeclList;
nonterminal Decl Decl;
nonterminal					ConstListDecls ConstListDecls;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal Const Const;
nonterminal					Type Type;
nonterminal ReturnType ReturnType;
nonterminal OptionalBrackets OptionalBrackets;
nonterminal Label Label;
nonterminal					VarListDeclList VarListDeclList;
nonterminal VarListDecls VarListDecls;
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal					ClassDecl ClassDecl;
nonterminal ClassMethodDecls ClassMethodDecls;
nonterminal MethodDeclList MethodDeclList;
nonterminal MethodDecl MethodDecl;
nonterminal ExtendsClause ExtendsClause;
nonterminal					RecordDecl RecordDecl;
nonterminal					FormPars FormPars;
nonterminal FormParamList FormParamList;
nonterminal FormParam FormParam;
nonterminal					Statements Statements;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal SingleStatement SingleStatement;
nonterminal					Expr Expr;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal					Designator Designator;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal IndexingList IndexingList;
nonterminal Indexing Indexing;
nonterminal					OptActPars OptActPars;
nonterminal ActPars ActPars;
nonterminal PrintPars PrintPars;
nonterminal					Mulop Mulop;
nonterminal Addop Addop;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal					Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;

nonterminal		rs.etf.pp1.symboltable.concepts.Obj		ProgName, Program;

/* Priorities */
precedence		left		ELSE;

/* Grammar Rules */
Program 			::=		(Program) PROG ProgName:p DeclList:D1 LBRACE RBRACE {: RESULT=new Program(p, D1); RESULT.setLine(pleft); :};

ProgName			::=		(ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

DeclList			::=		(Declarations) DeclList:D1 Decl:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
							|
							(NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */;
							
Decl				::=		(DeclConst) ConstListDecls:C1 {: RESULT=new DeclConst(C1); RESULT.setLine(C1left); :}
							|
							(DeclVar)	VarListDecls:V1 {: RESULT=new DeclVar(V1); RESULT.setLine(V1left); :}
							|
							(DeclClass) ClassDecl:C1 {: RESULT=new DeclClass(C1); RESULT.setLine(C1left); :}
							|
							(DeclRecord) RecordDecl:R1 {: RESULT=new DeclRecord(R1); RESULT.setLine(R1left); :}
							|
							error SEMI {: RESULT=new DeclDerived1(); :}
							|
							error COMMA {: RESULT=new DeclDerived2(); :};

ConstListDecls		::=		(ConstListDeclarations) CONST Type:T1 ConstDeclList:C2 SEMI {: RESULT=new ConstListDeclarations(T1, C2); RESULT.setLine(T1left); :};

ConstDeclList		::=		(MultipleConstDecls) ConstDeclList:C1 COMMA ConstDecl:C2 {: RESULT=new MultipleConstDecls(C1, C2); RESULT.setLine(C1left); :}
							|
							(SingleConstDecl) ConstDecl:C1 {: RESULT=new SingleConstDecl(C1); RESULT.setLine(C1left); :};
							
ConstDecl			::=		(ConstDecl) IDENT:I1 EQUAL Const:C2 {: RESULT=new ConstDecl(I1, C2); RESULT.setLine(I1left); :};

Const				::=		(NumConst) NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
							|
							(CharConst) CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
							|
							(BoolConst) BOOL {: RESULT=new BoolConst(); :};		
							
Type				::=		(Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};

Label				::=		(Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

VarListDecls		::=		(VarListDeclarations) Type:T1 VarDeclList:V2 SEMI {: RESULT=new VarListDeclarations(T1, V2); RESULT.setLine(T1left); :};

VarDeclList			::=		(MultipleVarDecls) VarDeclList:V1 COMMA VarDecl:V2 {: RESULT=new MultipleVarDecls(V1, V2); RESULT.setLine(V1left); :}
							|
							(SingleVarDecl) VarDecl:V1 {: RESULT=new SingleVarDecl(V1); RESULT.setLine(V1left); :};
							
VarDecl				::=		(VarDecl) IDENT:I1 OptionalBrackets:O2 {: RESULT=new VarDecl(I1, O2); RESULT.setLine(I1left); :};

OptionalBrackets	::=		(Brackets) LBRACKET RBRACKET {: RESULT=new Brackets(); :}
							|
							(NoBrackets) {: RESULT=new NoBrackets(); :} /* epsilon */;

ClassDecl			::=		(ClassDeclaration) CLASS IDENT:I1 ExtendsClause:E2 LBRACE VarListDeclList:V3 ClassMethodDecls:C4 RBRACE {: RESULT=new ClassDeclaration(I1, E2, V3, C4); RESULT.setLine(I1left); :};

ExtendsClause		::=		(Extends) EXTENDS Type:T1 {: RESULT=new Extends(T1); RESULT.setLine(T1left); :}
							|
							(NoExtends) {: RESULT=new NoExtends(); :} /* epsilon */;
					
VarListDeclList		::=		(VarListDeclarationList) VarListDeclList:V1 VarListDecls:V2 {: RESULT=new VarListDeclarationList(V1, V2); RESULT.setLine(V1left); :}
							|
							(NoVarListDeclarationList) {: RESULT=new NoVarListDeclarationList(); :} /* epsilon */;
							
RecordDecl			::=		(RecordDeclaration) RECORD IDENT:I1 LBRACE VarListDeclList:V2 RBRACE {: RESULT=new RecordDeclaration(I1, V2); RESULT.setLine(I1left); :};
											
ClassMethodDecls	::=		(ClassMethodDeclarations) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new ClassMethodDeclarations(M1); RESULT.setLine(M1left); :}
							|
							(NoClassMethodDeclarations) {: RESULT=new NoClassMethodDeclarations(); :} /* epsilon */;
							
MethodDeclList		::=		(MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
							|
							(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */;
							
MethodDecl			::=		(MethodDecl) ReturnType:R1 IDENT:I2 LPAREN FormPars:F3 RPAREN VarListDeclList:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new MethodDecl(R1, I2, F3, V4, S5); RESULT.setLine(R1left); :};

ReturnType			::=		(RetType) Type:T1 {: RESULT=new RetType(T1); RESULT.setLine(T1left); :}
							|
							(RetVoid) VOID {: RESULT=new RetVoid(); :};
							
FormPars			::=		(FormParams) FormParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :}
							|
							(NoFormParams) {: RESULT=new NoFormParams(); :} /* epsilon */;
							
FormParamList		::=		(MultipleFormParams) FormParamList:F1 COMMA FormParam:F2 {: RESULT=new MultipleFormParams(F1, F2); RESULT.setLine(F1left); :}
							|
							(SingleFormParam) FormParam:F1 {: RESULT=new SingleFormParam(F1); RESULT.setLine(F1left); :};

FormParam			::=		(FormalParameter) Type:T1 IDENT:I2 OptionalBrackets:O3 {: RESULT=new FormalParameter(T1, I2, O3); RESULT.setLine(T1left); :}
							|
							error {: RESULT=new FormParamDerived1(); :};
						
StatementList		::=		(Stmts) StatementList:S1 Statement:S2 {: RESULT=new Stmts(S1, S2); RESULT.setLine(S1left); :}
							|
							(NoStmt) {: RESULT=new NoStmt(); :} /* epsilon */;
							
Statement			::=		(SingleStmtWithLabel) Label:L1 COLON SingleStatement:S2 {: RESULT=new SingleStmtWithLabel(L1, S2); RESULT.setLine(L1left); :}
							|
							(SingleStmtNoLabel) SingleStatement:S1 {: RESULT=new SingleStmtNoLabel(S1); RESULT.setLine(S1left); :}
							|
							(MultipleStmts) Statements:S1 {: RESULT=new MultipleStmts(S1); RESULT.setLine(S1left); :};

Statements			::=		(Statements) LBRACE StatementList:S1 RBRACE {: RESULT=new Statements(S1); RESULT.setLine(S1left); :};

SingleStatement		::=		(IfStmt) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new IfStmt(C1, S2); RESULT.setLine(C1left); :}
							|
							(IfElseStmt) IF LPAREN Condition:C1 RPAREN Statement:S2 ELSE Statement:S3 {: RESULT=new IfElseStmt(C1, S2, S3); RESULT.setLine(C1left); :}
							|
							(DoWhileStmt) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new DoWhileStmt(S1, C2); RESULT.setLine(S1left); :}
							|
							(DesignatorStmt) DesignatorStatement:D1 SEMI {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
							|
							(BreakStmt) BREAK SEMI {: RESULT=new BreakStmt(); :}
							|
							(ContinueStmt) CONTINUE SEMI {: RESULT=new ContinueStmt(); :}
							|
							(GotoStmt) GOTO Label:L1 SEMI {: RESULT=new GotoStmt(L1); RESULT.setLine(L1left); :}
							|
							(ReturnNoExprStmt) RETURN SEMI {: RESULT=new ReturnNoExprStmt(); :}
							|
							(ReturnExprStmt) RETURN Expr:E1 SEMI {: RESULT=new ReturnExprStmt(E1); RESULT.setLine(E1left); :}
							|
							(ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
							|
							(PrintStmt) PRINT LPAREN PrintPars:P1 RPAREN SEMI {: RESULT=new PrintStmt(P1); RESULT.setLine(P1left); :};

Expr				::=		(MultipleExpr) Expr:E1 Addop:A2 Term:T3 {: RESULT=new MultipleExpr(E1, A2, T3); RESULT.setLine(E1left); :}
							|
							(SingleExpr) MINUS Term:T1 {: RESULT=new SingleExpr(T1); RESULT.setLine(T1left); :}
							|
							(SingleExprWithMinus) Term:T1 {: RESULT=new SingleExprWithMinus(T1); RESULT.setLine(T1left); :};
							
Term				::=		(MultipleTerm) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new MultipleTerm(T1, M2, F3); RESULT.setLine(T1left); :}
							|
							(SingleTerm) Factor:F1 {: RESULT=new SingleTerm(F1); RESULT.setLine(F1left); :};

Factor				::=		(FactorWithConst) Const:C1 {: RESULT=new FactorWithConst(C1); RESULT.setLine(C1left); :}
							|
							(FactorWithParen) LPAREN Expr:E1 RPAREN {: RESULT=new FactorWithParen(E1); RESULT.setLine(E1left); :}
							|
							(FactorWithNew) NEW Type:T1 {: RESULT=new FactorWithNew(T1); RESULT.setLine(T1left); :}
							|
							(FactorWithNewArray) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new FactorWithNewArray(T1, E2); RESULT.setLine(T1left); :}
							|
							(FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
							|
							(FactorDesignatorFuncCall) Designator:D1 LPAREN OptActPars:O2 RPAREN {: RESULT=new FactorDesignatorFuncCall(D1, O2); RESULT.setLine(D1left); :};
							
Designator			::=		(Designator) IDENT:I1 IndexingList:I2 {: RESULT=new Designator(I1, I2); RESULT.setLine(I1left); :};

IndexingList		::=		(MultipleIndexing) IndexingList:I1 Indexing:I2 {: RESULT=new MultipleIndexing(I1, I2); RESULT.setLine(I1left); :}
							|
							(NoIndexing) {: RESULT=new NoIndexing(); :} /* epsilon */;
							
Indexing			::=		(IndexingField) DOT IDENT:I1 {: RESULT=new IndexingField(I1); RESULT.setLine(I1left); :}
							|
							(IndexingArray) LBRACKET Expr:E1 RBRACKET {: RESULT=new IndexingArray(E1); RESULT.setLine(E1left); :};
							
OptActPars			::=		(WithOptActPars) ActPars:A1 {: RESULT=new WithOptActPars(A1); RESULT.setLine(A1left); :}
							|
							(NoOptActPars) {: RESULT=new NoOptActPars(); :} /* epsilon */; 
							
ActPars				::=		(MultipleActPars) ActPars:A1 COMMA Expr:E2 {: RESULT=new MultipleActPars(A1, E2); RESULT.setLine(A1left); :}
							|
							(SingleActPars) Expr:E1 {: RESULT=new SingleActPars(E1); RESULT.setLine(E1left); :};
							
Mulop				::=		(Mul) MUL {: RESULT=new Mul(); :}
							|
							(Div) DIV {: RESULT=new Div(); :}
							|
							(Percent) PERCENT {: RESULT=new Percent(); :};
							
Addop				::=		(Add) PLUS {: RESULT=new Add(); :}
							|
							(Minus) MINUS {: RESULT=new Minus(); :};
							
Assignop			::=		(Assignop) EQUAL {: RESULT=new Assignop(); :};
	
Relop				::=		(EqualTo) EQ {: RESULT=new EqualTo(); :}
							|
							(NotEqualTo) NEQ {: RESULT=new NotEqualTo(); :}
							|
							(GreaterThen) GT {: RESULT=new GreaterThen(); :}
							|
							(GreaterOrEqualThen) GTE {: RESULT=new GreaterOrEqualThen(); :}
							|
							(LessThen) LT {: RESULT=new LessThen(); :}
							|
							(LessOrEqualThen) LTE {: RESULT=new LessOrEqualThen(); :};
					
PrintPars			::=		(PrintParameters) Expr:E1 {: RESULT=new PrintParameters(E1); RESULT.setLine(E1left); :}
							|
							(PrintParametersWithConst) Expr:E1 COMMA NUMBER:N2 {: RESULT=new PrintParametersWithConst(E1, N2); RESULT.setLine(E1left); :};
							
DesignatorStatement	::=		(DesignatorStmtAssign) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStmtAssign(D1, A2, E3); RESULT.setLine(D1left); :}
							|
							Designator:D1 Assignop:A2 error {: RESULT=new DesignatorStatementDerived1(D1, A2); RESULT.setLine(D1left); :}
							|
							(DesignatorStmtFuncCall) Designator:D1 LPAREN OptActPars:O2 RPAREN {: RESULT=new DesignatorStmtFuncCall(D1, O2); RESULT.setLine(D1left); :}
							|
							(DesignatorStmtInc) Designator:D1 PLUSPLUS {: RESULT=new DesignatorStmtInc(D1); RESULT.setLine(D1left); :}
							|
							(DesignatorStmtDec) Designator:D1 MINUSMINUS {: RESULT=new DesignatorStmtDec(D1); RESULT.setLine(D1left); :};
							
Condition			::=		(MultipleConditions) Condition:C1 OR CondTerm:C2 {: RESULT=new MultipleConditions(C1, C2); RESULT.setLine(C1left); :}
							|
							(SingleCondition) CondTerm:C1 {: RESULT=new SingleCondition(C1); RESULT.setLine(C1left); :}
							|
							
							error {: RESULT=new ConditionDerived1(); :};
							
CondTerm			::=		(MultipleCondTerms) CondTerm:C1 AND CondFact:C2 {: RESULT=new MultipleCondTerms(C1, C2); RESULT.setLine(C1left); :}
							|
							(SingleCondTerm) CondFact:C1 {: RESULT=new SingleCondTerm(C1); RESULT.setLine(C1left); :};
							
CondFact			::=		(SingleCondFact) Expr:E1 {: RESULT=new SingleCondFact(E1); RESULT.setLine(E1left); :}
							|
							(DoubleCondFact) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new DoubleCondFact(E1, R2, E3); RESULT.setLine(E1left); :};